<?php
/*
	include/application/inc_bind.php

	Functions for manipulating configuration for the bind nameserver
*/



class bind_api extends soap_api
{
	var $domains;		// array of domain data
	var $records;		// associate array of domain record data


	/*
		check_permissions

		Checks the permissions of all the configuration files and returns an error if incorrect.

		Returns
		0	Incorrect permissions
		1	All good
	*/
	function check_permissions()
	{
		log_write("debug", "bind_config", "Executing check_permissions()");

		if (!is_writable($GLOBALS["config"]["bind"]["config"]))
		{
			log_write("error", "script", "Unable to write to Bind configuration file ". $GLOBALS["config"]["bind"]["config"]);

			return 0;
		}
		if (!is_writable($GLOBALS["config"]["bind"]["zonefiledir"]))
		{
			log_write("error", "script", "Unable to write to zone file directory ". $GLOBALS["config"]["bind"]["zonefiledir"]);

			return 0;
		}

		return 1;

	} // end of check_permissions



	/*
		check_domain_serial

		Read the zonefile for the serial and return the result, used to be able to
		compare zonefiles on disk with versions in the database
	
		Fields
		domainname	Name of the domain

		Returns
		0		Unknown zone or unreadable file
		#		Serial Number of the zone file (int)
	*/

	function check_domain_serial( $domain_name )
	{
		// TODO:	Implement this function in future
		// 		Not an urgent requirement ATM, but will be needed for increased
		//		application scalibility when handling large numbers of domains.
		
		return 0;

	} // end of check_domain_serial




	/*
		action_reload

		Reloads the Bind nameserver after new configuration has been written.

		Returns
		0		Failure
		1		Success
	*/
	function action_reload()
	{
		log_write("debug", "script", "Reloading Bind with new configuration using ". $GLOBALS["config"]["bind"]["reload"] ."");

		exec($GLOBALS["config"]["bind"]["reload"], $exec_output, $exec_return_value);

		if ($exec_return_value)
		{
			// an error occured
			log_write("error", "script", "Unable to confirm successful reload of Bind, potentially a configuration generation problem");

			return 0;
		}
		else
		{
			// Success!
			log_write("debug", "script", "Bind successfully reloaded with new configuration");

			return 1;
		}

	} // end of action_reload



	/*
		action_update

		Updates the configuration for the Bind nameserver and all zones.

		Returns
		0		Failure
		1		Success
	*/
	
	function action_update()
	{
		log_write("debug", "script", "Executing action_update()");

		// fetch domains and their status from the API
		$this->domains = $this->fetch_domains();

		foreach ($this->domains as $domain)
		{
			if ($this->check_domain_serial($domain["domain_name"]) == $domain["soa_serial"])
			{
				// domain is up to date
				log_write("debug", "script", "Domain ". $domain["domain_name"] ." is all up to date (serial: ". $domain["soa_serial"] .")");
			}
			else
			{
				// domain is out of date
				log_write("debug", "script", "Domain ". $domain["domain_name"] ." is out of date - configuration needs to be regenerated");

				// update the zone file
				$this->action_generate_zonefile( $domain["domain_name"], $domain["id"] );
			}
		}


		// remove any deleted domain zonefiles
		$this->action_remove_deleted();

		// update application configuration
		$this->action_generate_appconfig();


		// reload Bind
		$this->action_reload();
	}


	
	/*
		action_generate_appconfig

		Generates a new application configuration file for all domains in $this->domains.

		Returns
		0		Failure
		1		Success
	*/
	function action_generate_appconfig()
	{
		log_write("debug", "script", "Generating Bind application configuration file (". $GLOBALS["config"]["bind"]["config"] .")");

		if (!$fh = fopen($GLOBALS["config"]["bind"]["config"], "w"))
		{
			log_write("error", "main", "Unable to open file ". $GLOBALS["config"]["bind"]["config"] ." for writing");
			return 0;
		}

		fwrite($fh, "//\n");
		fwrite($fh, "// NamedManager Configuration\n");
		fwrite($fh, "//\n");
		fwrite($fh, "// This file is automatically generated any manual changes will be lost.\n");
		fwrite($fh, "//\n");

		foreach ($this->domains as $domain)
		{
			fwrite($fh, "zone \"". $domain["domain_name"] ."\" IN {\n");
			fwrite($fh, "\ttype master;\n");
			fwrite($fh, "\tfile \"". $domain["domain_name"] .".zone\";\n");
			fwrite($fh, "\tallow-update { none; };\n");
			fwrite($fh, "};\n");
		}

		fclose($fh);


		log_write("debug", "script", "Finished writing application configuration");

		return 1;

	} // end of action_generate_app_config



	/*
		action_remove_deleted

		Checks the list of domains returned from namedmanager and deletes any from the host
		that no longer valid.

		Returns
		0		Failure
		1		Success
	*/
	function action_remove_deleted()
	{
		log_write("debug", "script", "Executing action_remove_deleted()");


		// fetch list of domains from old config
		if (!$file = file($GLOBALS["config"]["bind"]["config"]))
		{
			log_write("error", "main", "Unable to open file ". $GLOBALS["config"]["bind"]["config"] ." for reading");
			return 0;
		}

		foreach ($file as $line)
		{
			// fetch the old domains
			if (preg_match("/zone\s\"(\S*)\"\sIN/", $line, $matches))
			{
				$domains_old[]	= $matches[1];
			}
		}


		// fetch equalivent list of new domains
		foreach ($this->domains as $domain)
		{
			$domains_new[] = $domain["domain_name"];
		}


		// compare with current domains
		foreach ($domains_old as $domain)
		{
			if (!in_array($domain, $domains_new))
			{
				// domain has been deleted
				log_write("debug", "script", "Domain $domain has been deleted, removing old configuration file");
				unlink( $GLOBALS["config"]["bind"]["zonefiledir"] ."/". $domain .".zone" );
			}
			
		}

		return 1;

	} // end of action_remove_deleted



	/*
		action_generate_zonefile

		Generates a new zonefile for the selected domain and replaces any existing ones. Most of this function
		is logic for handling and formatting the different types of domain records correctly and
		resolving challanges such as FQDN.

		Fields
		domain_name	Named of the domain
		domain_id	ID of the domain

		Returns
		0		Failure to generate zonefile
		1		Successful generation
	*/

	function action_generate_zonefile( $domain_name, $domain_id )
	{
		log_write("debug", "script", "Executing action_generate_zonefile ($domain_name, $domain_id)");
		log_write("debug", "script", "Generating new zonefile for $domain_name");


		$zonefile = $GLOBALS["config"]["bind"]["zonefiledir"] ."/". $domain_name .".zone";


		// open zonefile for writing
		if (!$fh = fopen($zonefile, "w"))
		{
			log_write("error", "main", "Unable to open file ". $zonefile ." for writing");
			return 0;
		}


		// fetch the domain records
		$this->records = $this->fetch_records( $domain_id );


		// check that there are records that can be written
		if (!$this->records)
		{
			log_write("warning", "script", "No records have been configured for domain, zonefile will be empty");

			$this->records = array();
		}



		// SOA record
//		fwrite($fh, "$domain_name\n");
//		fwrite($fh, "// This file is automatically generated any manual changes will be lost.\n");
//		fwrite($fh, "//\n");

		foreach ($this->domains as $domain)
		{
			if ($domain["id"] == $domain_id)
			{
				// header
				fwrite($fh, "\$ORIGIN ". $domain["domain_name"] .".\n");
				fwrite($fh, "\$TTL ". $domain["soa_default_ttl"] ."\n");

				// change @ to . for hostmaster email address
				$domain["soa_hostmaster"] = str_replace("@", ".", $domain["soa_hostmaster"]);

				// create SOA record from domain information
				fwrite($fh, "@\t\tIN SOA ". $domain["soa_ns_primary"] .". ". $domain["soa_hostmaster"] .". (\n");
				fwrite($fh, "\t\t\t". $domain["soa_serial"] ." ; serial\n");
				fwrite($fh, "\t\t\t". $domain["soa_refresh"] ." ; refresh\n");
				fwrite($fh, "\t\t\t". $domain["soa_retry"] ." ; retry\n");
				fwrite($fh, "\t\t\t". $domain["soa_expire"] ." ; expiry\n");
				fwrite($fh, "\t\t\t". $domain["soa_default_ttl"] ." ; minimum ttl\n");
				fwrite($fh, "\t\t)\n");

			}
		}


		// NS records
		fwrite($fh, "\n");
		fwrite($fh, "; Nameservers\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "NS")
			{
				// handle origin and content format
				if (preg_match("/\./", $record["record_content"]))
				{
					$record["record_content"]	= $record["record_content"] .".";
				}

				if (preg_match("/\./", $record["record_name"]) && preg_match("/". $domain_name ."$/", $record["record_name"]))
				{
					$record["record_name"]		= $record["record_name"] .".";
				}



				// write line
				fwrite($fh, "". $record["record_name"] ."\t". $record["record_ttl"] ." IN NS ". $record["record_content"] ."\n");
			}
		}


		// MX records
		fwrite($fh, "\n");
		fwrite($fh, "; Mailservers\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "MX")
			{
				// handle origin and content format
				if (preg_match("/\./", $record["record_content"]))
				{
					$record["record_content"]	= $record["record_content"] .".";
				}

				if (preg_match("/\./", $record["record_name"]) && preg_match("/". $domain_name ."$/", $record["record_name"]))
				{
					$record["record_name"]		= $record["record_name"] .".";
				}

				// write line
				fwrite($fh, "".$record["record_name"] ."\t". $record["record_ttl"] ." IN MX ". $record["record_prio"] ." ". $record["record_content"] ."\n");
			}
		}

		
		// PTR records
		fwrite($fh, "\n");
		fwrite($fh, "; Reverse DNS Records (PTR)\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "PTR")
			{
				fwrite($fh, $record["record_name"] . "\t". $record["record_ttl"] ." IN PTR ". $record["record_content"] );

				if (preg_match("/\./", $record["record_content"]))
				{
					// FQDN
					fwrite($fh, ".\n");
				}
				else
				{
					// non-FQND
					fwrite($fh, "\n");
				}

			}
		}


		// CNAME records
		fwrite($fh, "\n");
		fwrite($fh, "; CNAME\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "CNAME")
			{
				if (preg_match("/\./", $record["record_name"]) && preg_match("/". $domain_name ."$/", $record["record_name"]))
				{
					$record["record_name"] .= ".";	// append . as FQDN
				}

				fwrite($fh, $record["record_name"] . "\t CNAME ". $record["record_content"] ."");

				if (preg_match("/\./", $record["record_content"]))
				{
					// FQDN
					fwrite($fh, ".\n");
				}
				else
				{
					// non-FQND
					fwrite($fh, "\n");
				}
			}
		}


		// A, AAAA and other host records
		fwrite($fh, "\n");
		fwrite($fh, "; HOST RECORDS\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if (!in_array($record["record_type"], array("NS", "MX", "PTR", "CNAME", "SOA")))
			{
				switch($record["record_type"])
				{
					case "A":
					case "AAAA":
					case "SPF":

						// Adjust to handle FQDN in name/origin
						if (preg_match("/\./", $record["record_name"]) && preg_match("/". $domain_name ."$/", $record["record_name"]))
						{
							$record["record_name"] .= ".";	// append . as FQDN
						}

					break;
					
					
					case "SRV":

						// Adjust to handle FQDN in name/origin
						if (preg_match("/\./", $record["record_name"]) && preg_match("/". $domain_name ."$/", $record["record_name"]))
						{
							$record["record_name"] .= ".";		// append . as FQDN
						}

						// Adjust to handle FQDN in server target
						if (preg_match("/\./", $record["record_content"]))
						{
							$record["record_content"] .= ".";	// append . as FQDN
						}
					break;


					case "TXT":
						// nothing to do
					break;

					default:
						// nothing to do
					break;
				}
			
				// write record
				fwrite($fh, $record["record_name"] . "\t". $record["record_ttl"] ." IN ". $record["record_type"] ." ". $record["record_content"] ."\n");
			}
		}


		// footer
		fclose($fh);

		return 1;


	} // end of action_generate_zonefile


} // end of class bind_config


?>
