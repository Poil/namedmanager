<?php
/*
	include/application/inc_bind.php

	Functions for manipulating configuration for the bind nameserver
*/



class bind_api extends soap_api
{
	var $domains;		// array of domain data
	var $records;		// associate array of domain record data


	/*
		check_permissions

		Checks the permissions of all the configuration files and returns an error if incorrect.

		Returns
		0	Incorrect permissions
		1	All good
	*/
	function check_permissions()
	{
		log_write("debug", "bind_config", "Executing check_permissions()");

		if (!is_writable($GLOBALS["config"]["bind"]["config"]))
		{
			log_write("error", "script", "Unable to write to Bind configuration file ". $GLOBALS["config"]["bind"]["config"]);

			return 0;
		}
		if (!is_writable($GLOBALS["config"]["bind"]["zonefiledir"]))
		{
			log_write("error", "script", "Unable to write to zone file directory ". $GLOBALS["config"]["bind"]["zonefiledir"]);

			return 0;
		}

		return 1;

	} // end of check_permissions



	/*
		check_domain_serial

		Read the zonefile for the serial and return the result, used to be able to
		compare zonefiles on disk with versions in the database
	
		Fields
		domainname	Name of the domain

		Returns
		0		Unknown zone or unreadable file
		#		Serial Number of the zone file (int)
	*/

	function check_domain_serial( $domain_name )
	{
		// TODO:	Implement this function in future
		// 		Not an urgent requirement ATM, but will be needed for increased
		//		application scalibility when handling large numbers of domains.
		
		return 0;

	} // end of check_domain_serial




	/*
		action_reload

		Reloads the Bind nameserver after new configuration has been written.

		Returns
		0		Failure
		1		Success
	*/
	function action_reload()
	{
		log_write("debug", "script", "Reloading Bind with new configuration using ". $GLOBALS["config"]["bind"]["reload"] ."");

		exec($GLOBALS["config"]["bind"]["reload"], $exec_output, $exec_return_value);

		if ($exec_return_value)
		{
			// an error occured
			log_write("error", "script", "Unable to confirm successful reload of Bind, potentially a configuration generation problem");

			return 0;
		}
		else
		{
			// Success!
			log_write("debug", "script", "Bind successfully reloaded with new configuration");

			return 1;
		}

	} // end of action_reload



	/*
		action_update

		Updates the configuration for the Bind nameserver and all zones.

		Returns
		0		Failure
		1		Success
	*/
	
	function action_update()
	{
		log_write("debug", "script", "Executing action_update()");

		// fetch domains and their status from the API
		$this->domains = $this->fetch_domains();

		foreach ($this->domains as $domain)
		{
			if ($this->check_domain_serial($domain["domain_name"]) == $domain["soa_serial"])
			{
				// domain is up to date
				log_write("debug", "script", "Domain ". $domain["domain_name"] ." is all up to date (serial: ". $domain["soa_serial"] .")");
			}
			else
			{
				// domain is out of date
				log_write("debug", "script", "Domain ". $domain["domain_name"] ." is out of date - configuration needs to be regenerated");

				// update the zone file
				$this->action_generate_zonefile( $domain["domain_name"], $domain["id"] );
			}
		}


		// update application configuration
		$this->action_generate_appconfig();


		// reload Bind
		$this->action_reload();
	}


	
	/*
		action_generate_appconfig

		Generates a new application configuration file for all domains in $this->domains.

		Returns
		0		Failure
		1		Success
	*/
	function action_generate_appconfig()
	{
		log_write("debug", "script", "Generating Bind application configuration file (". $GLOBALS["config"]["bind"]["config"] .")");

		if (!$fh = fopen($GLOBALS["config"]["bind"]["config"], "w"))
		{
			log_write("error", "main", "Unable to open file ". $GLOBALS["config"]["bind"]["config"] ." for writing");
			return 0;
		}

		fwrite($fh, "//\n");
		fwrite($fh, "// NamedManager Configuration\n");
		fwrite($fh, "//\n");
		fwrite($fh, "// This file is automatically generated any manual changes will be lost.\n");
		fwrite($fh, "//\n");

		foreach ($this->domains as $domain)
		{
			fwrite($fh, "zone \"". $domain["domain_name"] ."\" IN {\n");
			fwrite($fh, "\ttype master;\n");
			fwrite($fh, "\tfile \"". $domain["domain_name"] .".zone\";\n");
			fwrite($fh, "\tallow-update { none; };\n");
			fwrite($fh, "};\n");
		}

		fclose($fh);


		log_write("debug", "script", "Finished writing application configuration");

		return 1;

	} // end of action_generate_app_config



	/*
		action_generate_zonefile

		Generates a new zonefile for the selected domain and replaces any existing ones. Most of this function
		is logic for handling and formatting the different types of domain records correctly and
		resolving challanges such as FQDN.

		Fields
		domain_name	Named of the domain
		domain_id	ID of the domain

		Returns
		0		Failure to generate zonefile
		1		Successful generation
	*/

	function action_generate_zonefile( $domain_name, $domain_id )
	{
		log_write("debug", "script", "Executing action_generate_zonefile ($domain_name, $domain_id)");
		log_write("debug", "script", "Generating new zonefile for $domain_name");


		$zonefile = $GLOBALS["config"]["bind"]["zonefiledir"] ."/". $domain_name .".zone";


		// open zonefile for writing
		if (!$fh = fopen($zonefile, "w"))
		{
			log_write("error", "main", "Unable to open file ". $zonefile ." for writing");
			return 0;
		}


		// fetch the domain records
		$this->records = $this->fetch_records( $domain_id );


		// check that there are records that can be written
		if (!$this->records)
		{
			log_write("warning", "script", "No records have been configured for domain, zonefile will be empty");

			$this->records = array();
		}



		// SOA record
//		fwrite($fh, "$domain_name\n");
//		fwrite($fh, "// This file is automatically generated any manual changes will be lost.\n");
//		fwrite($fh, "//\n");

		foreach ($this->domains as $domain)
		{
			if ($domain["id"] == $domain_id)
			{
				// header
				fwrite($fh, "\$ORIGIN ". $domain["domain_name"] .".\n");
				fwrite($fh, "\$TTL ". $domain["soa_default_ttl"] ."\n");

				// change @ to . for hostmaster email address
				$domain["soa_hostmaster"] = str_replace("@", ".", $domain["soa_hostmaster"]);

				// create SOA record from domain information
				fwrite($fh, "@\t\tIN SOA ". $domain["soa_ns_primary"] .". ". $domain["soa_hostmaster"] .". (\n");
				fwrite($fh, "\t\t\t". $domain["soa_serial"] ." ; serial\n");
				fwrite($fh, "\t\t\t". $domain["soa_refresh"] ." ; refresh\n");
				fwrite($fh, "\t\t\t". $domain["soa_retry"] ." ; retry\n");
				fwrite($fh, "\t\t\t". $domain["soa_expire"] ." ; expiry\n");
				fwrite($fh, "\t\t\t". $domain["soa_default_ttl"] ." ; minimum ttl\n");
				fwrite($fh, "\t\t)\n");

			}
		}


		// NS records
		fwrite($fh, "\n");
		fwrite($fh, "; Nameservers\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "NS")
			{
				fwrite($fh, "@\t\t\t". $record["record_ttl"] ." IN NS ". $record["record_content"] );

				if (preg_match("/./", $record["record_content"]))
				{
					// FQDN
					fwrite($fh, ".\n");
				}
				else
				{
					// non-FQND
					fwrite($fh, "\n");
				}
			}
		}


		// MX records
		fwrite($fh, "\n");
		fwrite($fh, "; Mailservers\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "MX")
			{
				fwrite($fh, "@\t\t\t". $record["record_ttl"] ." IN MX ". $record["record_prio"] ." ". $record["record_content"] ."");

				if (preg_match("/./", $record["record_content"]))
				{
					// FQDN
					fwrite($fh, ".\n");
				}
				else
				{
					// non-FQND
					fwrite($fh, "\n");
				}
			}
		}

		
		// PTR records
		fwrite($fh, "\n");
		fwrite($fh, "; Reverse DNS Records (PTR)\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "PTR")
			{
				fwrite($fh, $record["record_name"] . "\t". $record["record_ttl"] ." IN PTR ". $record["record_content"] );

				if (preg_match("/\./", $record["record_content"]))
				{
					// FQDN
					fwrite($fh, ".\n");
				}
				else
				{
					// non-FQND
					fwrite($fh, "\n");
				}

			}
		}


		// CNAME records
		fwrite($fh, "\n");
		fwrite($fh, "; CNAME\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if ($record["record_type"] == "CNAME")
			{
				if (preg_match("/\./", $record["record_name"]))
				{
					$record["record_name"] .= ".";	// append . as FQDN
				}

				fwrite($fh, $record["record_name"] . "\t CNAME ". $record["record_content"] ."");

				if (preg_match("/\./", $record["record_content"]))
				{
					// FQDN
					fwrite($fh, ".\n");
				}
				else
				{
					// non-FQND
					fwrite($fh, "\n");
				}
			}
		}


		// A, AAAA and other host records
		fwrite($fh, "\n");
		fwrite($fh, "; HOST RECORDS\n");
		fwrite($fh, "\n");

		foreach ($this->records as $record)
		{
			if (!in_array($record["record_type"], array("NS", "MX", "PTR", "CNAME", "SOA")))
			{
				if (preg_match("/\./", $record["record_name"]))
				{
					$record["record_name"] .= ".";	// append . as FQDN
				}

				fwrite($fh, $record["record_name"] . "\t". $record["record_ttl"] ." IN ". $record["record_type"] ." ". $record["record_content"] ."\n");
			}
		}


		// footer
		fclose($fh);

/*
$ORIGIN .
$TTL 1800	; 30 minutes

local.jethrocarr.com	IN SOA	ns1.amberdms.com. support.local.amberdms.com. (
				2010040301 ; serial
				10800      ; refresh (3 hours)
				900        ; retry (15 minutes)
				604800     ; expire (1 week)
				1800       ; minimum (30 minutes)
				)

			NS	ns1.amberdms.com.
			NS	ns2.amberdms.com.

			MX	10 pub-v1n1.local.jethrocarr.com.
			MX	20 pub-v1n2.local.jethrocarr.com.

bob			A	192.168.0.1
christine		A	10.8.5.129
crystal			A	10.8.5.134
jessie			A	10.8.5.135
lisa			A	10.8.5.136
mitchell-bob		A	10.8.5.147
mitchell-desktop	A	10.8.5.145
mitchell-laptop		A	10.8.5.146
phone-mobile-jethro1	A	10.8.5.150
phone-mobile-jethro2	A	10.8.5.151
phone-mobile-tom	A	10.8.5.152
ps3			A	10.8.5.140
sophie			A	10.8.5.201
tim-desktop		A	10.8.5.137
tom-desktop		A	10.8.5.138
tom-laptop		A	10.8.5.139
wifi-netgear		A	10.8.5.130
*/



		return 1;


	} // end of action_generate_zonefile


} // end of class bind_config


?>
